import Mathlib.CategoryTheory.ConcreteCategory.Bundled
import Mathlib.CategoryTheory.ConcreteCategory.BundledHom
import Mathlib.Algebra.GroupRingAction.Basic
import Mathlib.CategoryTheory.Category.Basic
import Mathlib.RepresentationTheory.Action
import Mathlib.GroupTheory.GroupAction.Hom
import Mathlib.Algebra.Category.Ring.Basic
import Mathlib.Algebra.Ring.Hom.Defs

-- Fix a monoid `M`, how to constrcut the `Category` of semiring with an `M` action?
-- 1. Bundle a wrapper of `MulSemiringAction`
-- 2. `Action M Semiring`
-- We show they are equivalent.

-- TODO?: extend `MulSemiringActionHom` to change of groups?

open CategoryTheory

universe v u

variable (M : Type u) [Monoid M]

-- class MulSemiringAction' (carrier : Type v) where
--   [isSemiring : Semiring carrier]
--   [isMulSemiringAction : MulSemiringAction M carrier]

-- #check Bundled (MulSemiringAction' M)

structure MulSemiringActionCat where
  carrier : Type v
  [isSemiring : Semiring carrier]
  [isMulSemiringAction : MulSemiringAction M carrier]

attribute [instance] MulSemiringActionCat.isSemiring MulSemiringActionCat.isMulSemiringAction

instance : CoeSort (MulSemiringActionCat.{v} M) (Type v) :=
  ‚ü®MulSemiringActionCat.carrier‚ü©

attribute [coe] MulSemiringActionCat.carrier

instance mulSemiringActionCategory :
    Category.{v, max (v+1) u} (MulSemiringActionCat.{v} M) where
  Hom R S := MulSemiringActionHom M R S
  id _ := MulSemiringActionHom.id M
  comp f g := MulSemiringActionHom.comp g f
  -- id_comp := MulSemiringActionHom.id_comp
  -- comp_id := MulSemiringActionHom.comp_id
  -- assoc f g h := sorry

instance {R S : MulSemiringActionCat.{v} M} :
    MulSemiringActionHomClass (R ‚ü∂ S) M R S :=
  MulSemiringActionHom.instMulSemiringActionHomClassMulSemiringActionHomToDistribMulActionToDistribMulAction M R S
-- This naming is abhorrent

instance moduleConcreteCategory :
    ConcreteCategory.{v} (MulSemiringActionCat.{v} M) where
  forget := {
    obj := fun R => R
    map := fun f => f.toFun
  }
  forget_faithful := {
    map_injective := by
      intro R S f g h
      apply MulSemiringActionHom.ext
      exact congrFun h
  }
    -- ‚ü®fun h => MulSemiringActionHom.ext (fun x => by
    --   dsimp at h
    --   rw [h])‚ü©
-- why different proof for module?

instance {R : MulSemiringActionCat.{v} M} :
    Semiring ((forget (MulSemiringActionCat M)).obj R) :=
  (inferInstance : Semiring R)

instance {R : MulSemiringActionCat.{v} M} :
    MulSemiringAction M ((forget (MulSemiringActionCat M)).obj R) :=
  (inferInstance : MulSemiringAction M R)

@[ext]
lemma ext {R S : MulSemiringActionCat.{v} M} {f‚ÇÅ f‚ÇÇ : R ‚ü∂ S} (h : ‚àÄ (r : R), f‚ÇÅ r = f‚ÇÇ r) : f‚ÇÅ = f‚ÇÇ :=
  FunLike.ext _ _ h

instance hasForgetToSemiring : HasForget‚ÇÇ (MulSemiringActionCat M) SemiRingCat where
  forget‚ÇÇ := {
    obj := fun R => SemiRingCat.of R
    map := fun f => SemiRingCat.ofHom f.toRingHom
  }

-- Semiring or SemiRing????
def of (R : Type v) [Semiring R] [MulSemiringAction M R] :
    MulSemiringActionCat M :=
  ‚ü®R‚ü©

/--
Forgeting an object in the action category to semiring category
is defeq to
the coesion to the underlying semiring in the semiring category
-/
@[simp]
theorem forget‚ÇÇ_obj (R : MulSemiringActionCat M) :
    (forget‚ÇÇ (MulSemiringActionCat M) SemiRingCat).obj R = SemiRingCat.of R :=
  rfl

/--
Given the data of an actioned ring
assemble to the object in action category
then forget to semiring category
is defeq to
assemble to the object in semiring category
-/
@[simp]
theorem forget‚ÇÇ_obj_SemiRingCat_of (R : Type v) [Semiring R] [MulSemiringAction M R] :
    SemiRingCat.of (of M R) = SemiRingCat.of R :=
  rfl
-- It is said this is not used?

/--
Forgeting a morphism in the action category to semiring category
is defeq to
the coesion to the underlying semiring morphism in the semiring category
-/
@[simp]
theorem forget‚ÇÇ_map (R S : MulSemiringActionCat M) (f : R ‚ü∂ S) :
    (forget‚ÇÇ (MulSemiringActionCat M) SemiRingCat).map f = MulSemiringActionHom.toRingHom f :=
  rfl

/-- Typecheck a `MulSemiringActionHom` as a morphism in `MulSemiringActionCat M`. -/
def ofHom {R S : Type v} [Semiring R] [MulSemiringAction M R] [Semiring S]
    [MulSemiringAction M S] (f : MulSemiringActionHom M R S) : of M R ‚ü∂ of M S :=
  f

-- why simp 1100
@[simp]
theorem ofHom_apply {R S : Type v} [Semiring R] [MulSemiringAction M R]
    [Semiring S] [MulSemiringAction M S] (f : MulSemiringActionHom M R S) (r : R) : ofHom M f r = f r :=
  rfl

-- TODO?: Inhabited and Unique

-- Porting note: the simpNF linter complains, but we really need this?!
@[simp, nolint simpNF]
theorem coe_of (R : Type v) [Semiring R] [MulSemiringAction M R] :
    (of M R : Type v) = R :=
  rfl

@[simp]
theorem id_apply {R: MulSemiringActionCat.{v} M} (r : R) :
    (ùüô R : R ‚Üí R) r = r :=
  rfl

@[simp]
theorem coe_comp {R S T : MulSemiringActionCat.{v} M} (f : R ‚ü∂ S) (g : S ‚ü∂ T) :
    (f ‚â´ g : R ‚Üí T) = g ‚àò f :=
  rfl

@[simp]
theorem comp_def {R S T : MulSemiringActionCat.{v} M} (f : R ‚ü∂ S) (g : S ‚ü∂ T) :
    f ‚â´ g = g.comp f :=
  rfl

@[simp]
lemma forget_map {R S : MulSemiringActionCat.{v} M} (f : R ‚ü∂ S) :
    (forget (MulSemiringActionCat M)).map f = (f : R ‚Üí S) :=
  rfl

#check MulSemiringActionCat M
#check (Action SemiRingCat (MonCat.of M))

-- toRingHom is a monoid map
-- TODO: add these to MulSemiringActionHom
@[simp]
theorem
  this_for_map_one' (R : Type*) [Semiring R] [MulSemiringAction M R] :
    MulSemiringAction.toRingHom M R 1 = 1
  := by
    apply RingHom.ext
    simp only [MulSemiringAction.toRingHom_apply, one_smul, RingHom.coe_one, id_eq, forall_const]

@[simp]
theorem
  this_for_map_mul' (R : Type*) [Semiring R] [MulSemiringAction M R] :
    ‚àÄ (x y : M),
      MulSemiringAction.toRingHom M (‚ÜëR) (x * y) =
        MulSemiringAction.toRingHom M (‚ÜëR) x * MulSemiringAction.toRingHom M (‚ÜëR) y
  := by
    intros x y
    apply RingHom.ext
    simp only [MulSemiringAction.toRingHom_apply, RingHom.coe_mul, Function.comp_apply]
    intro r
    exact mul_smul x y r

-- @[simp]
def toRepHom (R : Type*) [Semiring R] [MulSemiringAction M R]:
  M ‚Üí* R ‚Üí+* R where
    toFun := MulSemiringAction.toRingHom M R
    map_one' := this_for_map_one' M R
    map_mul' := this_for_map_mul' M R

-- @[simp]
-- def comp (R S: Type*) [Semiring R] [Semiring S] [MulSemiringAction M R] [MulSemiringAction M S] (f: MulSemiringActionHom M R S) :
--     ‚àÄ m : M, ‚àÄ r : R, f (m ‚Ä¢ r) = m ‚Ä¢ f r := by
--       intros m r
--       exact MulSemiringActionHom.map_smul f m r

-- cat comp is type comp

-- def toSemiringHom (R S : Type*) [Semiring R] [Semiring S]
--   [MulSemiringAction M R] [MulSemiringAction M S]
--     (f : MulSemiringActionHom M R S):
--       R ‚Üí+* S where
--         toFun := f
--         map_one' := f.map_one
--         map_mul' := f.map_mul
--         map_zero' := f.map_zero
--         map_add' := f.map_add

-- instance (R S : MulSemiringActionCat M) :
--   Coe (R ‚ü∂ S) (R ‚Üí+* S) where
--     coe f := {
--       toFun := f.toFun
--       map_one' := f.map_one'
--       map_mul' := f.map_mul'
--       map_zero' := f.map_zero'
--       map_add' := f.map_add'
--     }

-- instance (R S : Type) [Semiring R] [Semiring S] :
--   Coe (R ‚Üí+* S) (R ‚ü∂ S) where
--     coe := sorry

-- This seems to be defeq??? not needed
-- instance (R S : MulSemiringActionCat.{v} M) :
--     Coe (R ‚ü∂ S) (MulSemiringActionHom M R S) where
--       coe f := {
--         toFun := f.toFun
--         map_smul' := MulActionHom.map_smul' f.toMulActionHom
--         map_one' := f.map_one'
--         map_mul' := f.map_mul'
--         map_zero' := f.map_zero'
--         map_add' := f.map_add'
--       }

-- variable (R S : MulSemiringActionCat M) (f: R ‚ü∂ S)
-- #check (f : MulSemiringActionHom M R S)
-- #check (f : R ‚Üí+* S)
-- #check (f : R ‚Üí S)

-- Does the same as SemiRingCat.coe_of?? not needed
-- @[simp]
theorem that (R : Type u) [Semiring R] (œÅ : M ‚Üí* ‚ÜëR ‚Üí+* ‚ÜëR) :
  ({ V := SemiRingCat.of R, œÅ := œÅ } : Action SemiRingCat (MonCat.of M)).V = SemiRingCat.of R := by
    rfl

@[simp]
theorem bar (M : Type) [Monoid M] :
    @Bundled.Œ± Monoid (MonCat.of M) = M := by
  rfl

@[simp]
theorem this (M : Type) [Monoid M] (X : MulSemiringActionCat M):
  ((MonCat.of M) ‚Üí* (MonCat.of (End (SemiRingCat.of X)))) = (M ‚Üí* (End (SemiRingCat.of X))) := by
    rfl

-- @[simp]
--   theorem tttt (M : Type) [Monoid M] (X Y : MulSemiringActionCat M) (m : (MonCat.of M)) (f : X ‚ü∂ Y) (r : X):
--     (((toRepHom M X) m) ‚â´ SemiRingCat.ofHom f) r = ( (toRepHom M X) m ) ‚àò f := sorry
    -- (((toRepHom M X) m) ‚â´ SemiRingCat.ofHom f) r = f ( (toRepHom M X m) r ) := by sorry

-- @[simp]
-- theorem foo (M R : Type) [Monoid M] [Semiring R]
--   (œÅ : (MonCat.of M) ‚Üí* (MonCat.of (End (SemiRingCat.of R))))
--     (f : R ‚Üí+* R) (m : M) :
--       (œÅ m) ‚â´ SemiRingCat.ofHom f =
  -- SemiRingCat.ofHom g ‚â´ SemiRingCat.ofHom f = SemiRingCat.ofHom (f.comp g) := by
  --   rfl


def functor : MulSemiringActionCat M ‚•§ Action SemiRingCat (MonCat.of M) where
  obj R := {
    V := SemiRingCat.of R
    œÅ := toRepHom M R
  }
  map f := {
    hom := SemiRingCat.ofHom f
    comm := by
      -- aesop
      -- apply RingHom.ext
      -- intros r
      /-
      case a
      M : Type u
      inst : Monoid M
      X Y : MulSemiringActionCat M
      f : X ‚ü∂ Y
      g : ‚Üë(MonCat.of M)
      r : ‚Üë(SemiRingCat.of ‚ÜëX)
      ‚ä¢ ‚Üë(‚Üë(toRepHom M ‚ÜëX) g ‚â´ SemiRingCat.ofHom ‚Üëf) r = ‚Üë(SemiRingCat.ofHom ‚Üëf ‚â´ ‚Üë(toRepHom M ‚ÜëY) g) r
      -/


      intros m
      apply RingHom.ext
      intros r
      simp only [SemiRingCat.coe_of] at r ‚ä¢

      /-
      case a
      M : Type u
      inst‚úù : Monoid M
      X‚úù Y‚úù : MulSemiringActionCat M
      f : X‚úù ‚ü∂ Y‚úù
      m : ‚Üë(MonCat.of M)
      r : ‚ÜëX‚úù
      ‚ä¢ ‚Üë(‚Üë(toRepHom M ‚ÜëX‚úù) m ‚â´ SemiRingCat.ofHom ‚Üëf) r = ‚Üë(SemiRingCat.ofHom ‚Üëf ‚â´ ‚Üë(toRepHom M ‚ÜëY‚úù) m) r
      -/

      rw [MonCat.coe_of] at m
      -- -- why `simp [bar] at m` not work?

      sorry
  }
